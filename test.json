{
  "foo": "bar",
  "baz": {
    "qux": 1,
    "hello": [ "world" ]
  }
}

// START OF OBJECT #
  // FOO => ARBITRARY_STRING
  // START OF OBJECT #/baz
    // QUX => UINT8
    // START OF ARRAY #/baz/hello
      // ELEMENT 0 => ARBITRARY_STRING
    // END OF ARRAY #/baz/hello
  // END OF OBJECT #/baz
// END OF OBJECT #

{
  // STRICTLY TYPED FINITE OBJECT
  "type": "object",
  "required": [ "foo", "baz" ],
  "additionalProperties": false,
  "properties": {
    // ARBITRARY_STRING
    "foo": {
      "type": "string"
    },
    // STRICTLY TYPED FINITE OBJECT
    "bar": {
      "type": "object",
      "required": [ "qux", "hello" ],
      "additionalProperties": false
      "properties": {

        // UINT8
        "qux": {
          "type": "integer"
        },

        // UNIFORM_ARRAY (STRING)
        "hello": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    }
  }
}

{
  type: STRICTLY_TYPED_FINITE_OBJECT,
  ref: #
  args: [ 2 ],
  children: [
    {
      type: ARBITRARY_STRING
      ref: #/foo
    },
    {
      type: STRICTLY_TYPED_FINITE_OBJECT
      ref: #/bar
      args: [ 2 ],
      children: [
        {
          type: UINT8
          ref: #/bar/qux
        }
        {
          type: UNIFORM_ARRAY,
          ref: #/bar/hello
          children: [
            { type: ARBITRARY_STRING }
          ]
        }
      ]
    }
  ]
}

absoluteMapper = (Schema) => [ ENCODINGS + REFS ]

STRICTLY_TYPED_FINITE_OBJECT = (buffer, offset, numberOfKeys, ...values) => {
  for value of values {
    type = value.type
    encoding = value.encoding
    actual_value = value.value

  }
}

encodingDefinitions = [
  {
    encoding: ARBITRARY_STRING
    type: string
  },
  {
    encoding: STRICTLY_TYPED_FINITE_OBJECT
    type: object
    args: [ 2 ],
  }
]

ARBITRARY_OBJECT (buffer, offset, object, orderedKeys[], encodingDefinitions[], additionalEncodingDefinition, propertyEncodingDefinition, requiredSet[], minProperties, maxProperties)
  XXX encode bit set for optionals using requiredSet, minProperties, and maxProperties
  for key of orderedKeys {
    value = object[key]

    if encodingDefinitions[index] {
      use that encoding
    } else if additionalEncodingDefinition {
      encode key as in propertyEncodingDefinition
      then use additional encoding for value
    }
  }

{
  encoding: STRICTLY_TYPED_FINITE_OBJECT,
  type: object
  ref: #
  options: {
    minProperties: 2,
    maxProperties: 2
  }
}
{
  encoding: ARBITRARY_STRING
  type: string
  ref: #/foo
},
{
  encoding: STRICTLY_TYPED_FINITE_OBJECT
  type: object
  ref: #/bar
  args: [ 2 ],
}
{
  encoding: UINT8
  type: integer
  ref: #/bar/qux
}
{
  encoding: UNIFORM_DYNAMIC_ARRAY,
  type: array
  ref: #/bar/hello
}
{
  encoding: ARBITRARY_STRING
  type: string
  ref: #/bar/hello/-
}
